/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FocusPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  clearMethod: "click-again"
};
var FocusPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.classes = {
      "enabled": "focus-plugin-enabled",
      "dimmed": "focus-plugin-dimmed",
      "focus-animation": "focus-plugin-focus-animation",
      "dim-animation": "focus-plugin-dim-animation"
    };
    this.paneInfo = /* @__PURE__ */ new WeakMap();
    this.order = ["H1", "H2", "H3", "H4", "H5", "H6"];
    this.observeHead = null;
  }
  findContents(headNode, startNode) {
    var _a, _b;
    let contents = [];
    let nextNode = startNode;
    let headTag = (_a = headNode.firstElementChild) == null ? void 0 : _a.tagName;
    if (!headTag || !this.order.includes(headTag))
      return contents;
    while (nextNode) {
      let currentTag = (_b = nextNode.firstElementChild) == null ? void 0 : _b.tagName;
      if (currentTag && this.order.includes(currentTag) && this.order.indexOf(currentTag) <= this.order.indexOf(headTag))
        break;
      contents.push(nextNode);
      nextNode = nextNode.nextElementSibling;
    }
    return contents;
  }
  dim_node(node, animation) {
    if (animation) {
      node.addEventListener("animationend", () => {
        node.classList.remove(this.classes["dim-animation"]);
      }, { once: true });
      node.classList.add(this.classes["dim-animation"]);
    }
    node.classList.add(this.classes["dimmed"]);
  }
  undim_node(node, animation) {
    if (animation) {
      node.addEventListener("animationend", () => {
        node.classList.remove(this.classes["focus-animation"]);
      }, { once: true });
      node.classList.add(this.classes["focus-animation"]);
    }
    node.classList.remove(this.classes["dimmed"]);
  }
  clear(target, animation) {
    if (!target) {
      document.querySelectorAll(`.${this.classes["dimmed"]}`).forEach((node) => this.undim_node(node, animation));
      this.paneInfo = /* @__PURE__ */ new WeakMap();
      return;
    }
    target.querySelectorAll(`.${this.classes["dimmed"]}`).forEach((node) => this.undim_node(node, animation));
    this.paneInfo.delete(target);
  }
  observe() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view && view.getMode() === "preview") {
      this.observeHead = view.contentEl.querySelector(".markdown-preview-section");
      this.observer.observe(this.observeHead, { childList: true });
      console.log("focus-plugin: observing");
    }
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "clear-focus",
        name: "Clear Focus",
        callback: () => {
          this.clear(null, false);
        }
      });
      this.addSettingTab(new FocusPluginSettingTab(this.app, this));
      document.body.classList.add(this.classes["enabled"]);
      this.observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          const observeHead = mutation.target;
          if (!this.paneInfo.has(observeHead)) {
            this.clear(observeHead, false);
            return;
          }
          const focusInfo = this.paneInfo.get(observeHead);
          if (mutation.addedNodes.length > 0) {
            [focusInfo.focusHead, ...focusInfo.focusBody].forEach((content) => {
              let nextNode = content.nextElementSibling;
              if (nextNode) {
                let newNodes = this.findContents(focusInfo.focusHead, nextNode);
                newNodes.forEach((node) => {
                  this.undim_node(node, false);
                  focusInfo.focusBody.add(node);
                });
              }
            });
          }
          const allNodes = Array.from(observeHead.children);
          allNodes.forEach((node) => {
            if (!focusInfo.focusBody.has(node) && node !== focusInfo.focusHead)
              this.dim_node(node, false);
          });
        });
      });
      this.registerEvent(this.app.workspace.on("layout-change", () => {
        this.observe();
        this.clear(this.observeHead, false);
      }));
      this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
        this.observe();
      }));
      this.registerDomEvent(document, "click", (evt) => __async(this, null, function* () {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (!markdownView || markdownView.getMode() !== "preview" || !(evt.target instanceof Element) || !this.observeHead)
          return;
        const element = evt.target.hasAttribute("data-heading") ? evt.target : evt.target.parentElement || evt.target;
        const block = element.parentElement;
        if (this.paneInfo.has(this.observeHead)) {
          const focusInfo2 = this.paneInfo.get(this.observeHead);
          switch (this.settings.clearMethod) {
            case "click-again":
              if (block && focusInfo2.focusHead && block === focusInfo2.focusHead) {
                this.clear(this.observeHead, true);
                return;
              }
              break;
            case "click-outside":
              if (element.classList.contains("markdown-reading-view")) {
                this.clear(this.observeHead, true);
                return;
              }
              break;
          }
        }
        if (!block || !element.hasAttribute("data-heading"))
          return;
        let focusInfo = { focusHead: block, focusBody: /* @__PURE__ */ new Set() };
        let contents = [];
        if (block.nextElementSibling)
          contents = this.findContents(block, block.nextElementSibling);
        [block, ...contents].forEach((node) => {
          if (node.classList.contains(this.classes["dimmed"]))
            this.undim_node(node, true);
        });
        contents.forEach((content) => focusInfo.focusBody.add(content));
        const allNodes = Array.from(this.observeHead.children);
        allNodes.forEach((node) => {
          if (!focusInfo.focusBody.has(node) && node !== focusInfo.focusHead) {
            if (!node.classList.contains(this.classes["dimmed"]))
              this.dim_node(node, true);
          }
        });
        this.paneInfo.set(this.observeHead, focusInfo);
      }));
      this.observe();
    });
  }
  onunload() {
    document.body.classList.remove(this.classes["enabled"]);
    this.clear(null, false);
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var FocusPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Focus and Highlight Settings" });
    new import_obsidian.Setting(containerEl).setName("Clear Method").setDesc("How to clear the focused elements").addDropdown((dropdown) => dropdown.addOptions({
      "click-again": "Click again",
      "click-outside": "Click outside"
    }).setValue(this.plugin.settings.clearMethod).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.clearMethod = value;
      yield this.plugin.saveSettings();
      console.log("focus-plugin: clear method changed to " + value);
    })));
  }
};
